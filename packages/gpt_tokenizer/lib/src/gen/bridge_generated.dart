// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.72.1.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, unnecessary_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names, invalid_use_of_internal_member, prefer_is_empty, unnecessary_const

import 'dart:convert';
import 'dart:async';
import 'package:meta/meta.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';

import 'dart:convert';
import 'dart:async';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'bridge_generated.io.dart'
    if (dart.library.html) 'bridge_generated.web.dart';

abstract class GptTokenizer {
  Future<BPEWrapper> createStaticMethodBpeWrapper(
      {required List<EncoderMapEntry> encoderEntries,
      required List<SpecialEncoderMapEntry> specialTokensEncoderEntries,
      required String pattern,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCreateStaticMethodBpeWrapperConstMeta;

  Future<BPEWrapper> loadStaticMethodBpeWrapper(
      {required String path,
      required List<SpecialEncoderMapEntry> specialTokensEncoderEntries,
      required String pattern,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLoadStaticMethodBpeWrapperConstMeta;

  Future<Uint32List> encodeOrdinaryMethodBpeWrapper(
      {required BPEWrapper that, required String text, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kEncodeOrdinaryMethodBpeWrapperConstMeta;

  Future<Uint32List> encodeMethodBpeWrapper(
      {required BPEWrapper that,
      required String text,
      required List<String> allowedSpecialEntries,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kEncodeMethodBpeWrapperConstMeta;

  Future<int> countTokenMethodBpeWrapper(
      {required BPEWrapper that,
      required String text,
      required List<String> allowedSpecialEntries,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCountTokenMethodBpeWrapperConstMeta;

  Future<Uint8List> encodeBytesMethodBpeWrapper(
      {required BPEWrapper that, required Uint8List bytes, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kEncodeBytesMethodBpeWrapperConstMeta;

  Future<int> encodeSingleTokenMethodBpeWrapper(
      {required BPEWrapper that, required Uint8List piece, dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kEncodeSingleTokenMethodBpeWrapperConstMeta;

  Future<Uint8List> decodeBytesMethodBpeWrapper(
      {required BPEWrapper that, required Uint32List tokens, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDecodeBytesMethodBpeWrapperConstMeta;

  Future<Uint8List> decodeSingleTokenBytesMethodBpeWrapper(
      {required BPEWrapper that, required int token, dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kDecodeSingleTokenBytesMethodBpeWrapperConstMeta;

  DropFnType get dropOpaqueCoreBpe;
  ShareFnType get shareOpaqueCoreBpe;
  OpaqueTypeFinalizer get CoreBpeFinalizer;
}

@sealed
class CoreBpe extends FrbOpaque {
  final GptTokenizer bridge;
  CoreBpe.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueCoreBpe;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueCoreBpe;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.CoreBpeFinalizer;
}

class BPEWrapper {
  final GptTokenizer bridge;
  final CoreBpe bpe;

  const BPEWrapper({
    required this.bridge,
    required this.bpe,
  });

  static Future<BPEWrapper> create(
          {required GptTokenizer bridge,
          required List<EncoderMapEntry> encoderEntries,
          required List<SpecialEncoderMapEntry> specialTokensEncoderEntries,
          required String pattern,
          dynamic hint}) =>
      bridge.createStaticMethodBpeWrapper(
          encoderEntries: encoderEntries,
          specialTokensEncoderEntries: specialTokensEncoderEntries,
          pattern: pattern,
          hint: hint);

  static Future<BPEWrapper> load(
          {required GptTokenizer bridge,
          required String path,
          required List<SpecialEncoderMapEntry> specialTokensEncoderEntries,
          required String pattern,
          dynamic hint}) =>
      bridge.loadStaticMethodBpeWrapper(
          path: path,
          specialTokensEncoderEntries: specialTokensEncoderEntries,
          pattern: pattern,
          hint: hint);

  Future<Uint32List> encodeOrdinary({required String text, dynamic hint}) =>
      bridge.encodeOrdinaryMethodBpeWrapper(
        that: this,
        text: text,
      );

  Future<Uint32List> encode(
          {required String text,
          required List<String> allowedSpecialEntries,
          dynamic hint}) =>
      bridge.encodeMethodBpeWrapper(
        that: this,
        text: text,
        allowedSpecialEntries: allowedSpecialEntries,
      );

  Future<int> countToken(
          {required String text,
          required List<String> allowedSpecialEntries,
          dynamic hint}) =>
      bridge.countTokenMethodBpeWrapper(
        that: this,
        text: text,
        allowedSpecialEntries: allowedSpecialEntries,
      );

  Future<Uint8List> encodeBytes({required Uint8List bytes, dynamic hint}) =>
      bridge.encodeBytesMethodBpeWrapper(
        that: this,
        bytes: bytes,
      );

  Future<int> encodeSingleToken({required Uint8List piece, dynamic hint}) =>
      bridge.encodeSingleTokenMethodBpeWrapper(
        that: this,
        piece: piece,
      );

  Future<Uint8List> decodeBytes({required Uint32List tokens, dynamic hint}) =>
      bridge.decodeBytesMethodBpeWrapper(
        that: this,
        tokens: tokens,
      );

  Future<Uint8List> decodeSingleTokenBytes(
          {required int token, dynamic hint}) =>
      bridge.decodeSingleTokenBytesMethodBpeWrapper(
        that: this,
        token: token,
      );
}

class EncoderMapEntry {
  final Uint8List key;
  final int value;

  const EncoderMapEntry({
    required this.key,
    required this.value,
  });
}

class SpecialEncoderMapEntry {
  final String key;
  final int value;

  const SpecialEncoderMapEntry({
    required this.key,
    required this.value,
  });
}

class GptTokenizerImpl implements GptTokenizer {
  final GptTokenizerPlatform _platform;
  factory GptTokenizerImpl(ExternalLibrary dylib) =>
      GptTokenizerImpl.raw(GptTokenizerPlatform(dylib));

  /// Only valid on web/WASM platforms.
  factory GptTokenizerImpl.wasm(FutureOr<WasmModule> module) =>
      GptTokenizerImpl(module as ExternalLibrary);
  GptTokenizerImpl.raw(this._platform);
  Future<BPEWrapper> createStaticMethodBpeWrapper(
      {required List<EncoderMapEntry> encoderEntries,
      required List<SpecialEncoderMapEntry> specialTokensEncoderEntries,
      required String pattern,
      dynamic hint}) {
    var arg0 = _platform.api2wire_list_encoder_map_entry(encoderEntries);
    var arg1 = _platform
        .api2wire_list_special_encoder_map_entry(specialTokensEncoderEntries);
    var arg2 = _platform.api2wire_String(pattern);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner
          .wire_create__static_method__BPEWrapper(port_, arg0, arg1, arg2),
      parseSuccessData: (d) => _wire2api_bpe_wrapper(d),
      constMeta: kCreateStaticMethodBpeWrapperConstMeta,
      argValues: [encoderEntries, specialTokensEncoderEntries, pattern],
      hint: hint,
      parseErrorData: null,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCreateStaticMethodBpeWrapperConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "create__static_method__BPEWrapper",
        argNames: ["encoderEntries", "specialTokensEncoderEntries", "pattern"],
      );

  Future<BPEWrapper> loadStaticMethodBpeWrapper(
      {required String path,
      required List<SpecialEncoderMapEntry> specialTokensEncoderEntries,
      required String pattern,
      dynamic hint}) {
    var arg0 = _platform.api2wire_String(path);
    var arg1 = _platform
        .api2wire_list_special_encoder_map_entry(specialTokensEncoderEntries);
    var arg2 = _platform.api2wire_String(pattern);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner
          .wire_load__static_method__BPEWrapper(port_, arg0, arg1, arg2),
      parseSuccessData: (d) => _wire2api_bpe_wrapper(d),
      constMeta: kLoadStaticMethodBpeWrapperConstMeta,
      argValues: [path, specialTokensEncoderEntries, pattern],
      hint: hint,
      parseErrorData: null,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kLoadStaticMethodBpeWrapperConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "load__static_method__BPEWrapper",
        argNames: ["path", "specialTokensEncoderEntries", "pattern"],
      );

  Future<Uint32List> encodeOrdinaryMethodBpeWrapper(
      {required BPEWrapper that, required String text, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_bpe_wrapper(that);
    var arg1 = _platform.api2wire_String(text);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner
          .wire_encode_ordinary__method__BPEWrapper(port_, arg0, arg1),
      parseSuccessData: _wire2api_ZeroCopyBuffer_Uint32List,
      constMeta: kEncodeOrdinaryMethodBpeWrapperConstMeta,
      argValues: [that, text],
      hint: hint,
      parseErrorData: null,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kEncodeOrdinaryMethodBpeWrapperConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "encode_ordinary__method__BPEWrapper",
        argNames: ["that", "text"],
      );

  Future<Uint32List> encodeMethodBpeWrapper(
      {required BPEWrapper that,
      required String text,
      required List<String> allowedSpecialEntries,
      dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_bpe_wrapper(that);
    var arg1 = _platform.api2wire_String(text);
    var arg2 = _platform.api2wire_StringList(allowedSpecialEntries);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner
          .wire_encode__method__BPEWrapper(port_, arg0, arg1, arg2),
      parseSuccessData: _wire2api_ZeroCopyBuffer_Uint32List,
      constMeta: kEncodeMethodBpeWrapperConstMeta,
      argValues: [that, text, allowedSpecialEntries],
      hint: hint,
      parseErrorData: null,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kEncodeMethodBpeWrapperConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "encode__method__BPEWrapper",
        argNames: ["that", "text", "allowedSpecialEntries"],
      );

  Future<int> countTokenMethodBpeWrapper(
      {required BPEWrapper that,
      required String text,
      required List<String> allowedSpecialEntries,
      dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_bpe_wrapper(that);
    var arg1 = _platform.api2wire_String(text);
    var arg2 = _platform.api2wire_StringList(allowedSpecialEntries);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner
          .wire_count_token__method__BPEWrapper(port_, arg0, arg1, arg2),
      parseSuccessData: _wire2api_usize,
      constMeta: kCountTokenMethodBpeWrapperConstMeta,
      argValues: [that, text, allowedSpecialEntries],
      hint: hint,
      parseErrorData: null,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCountTokenMethodBpeWrapperConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "count_token__method__BPEWrapper",
        argNames: ["that", "text", "allowedSpecialEntries"],
      );

  Future<Uint8List> encodeBytesMethodBpeWrapper(
      {required BPEWrapper that, required Uint8List bytes, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_bpe_wrapper(that);
    var arg1 = _platform.api2wire_uint_8_list(bytes);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner
          .wire_encode_bytes__method__BPEWrapper(port_, arg0, arg1),
      parseSuccessData: _wire2api_ZeroCopyBuffer_Uint8List,
      constMeta: kEncodeBytesMethodBpeWrapperConstMeta,
      argValues: [that, bytes],
      hint: hint,
      parseErrorData: null,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kEncodeBytesMethodBpeWrapperConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "encode_bytes__method__BPEWrapper",
        argNames: ["that", "bytes"],
      );

  Future<int> encodeSingleTokenMethodBpeWrapper(
      {required BPEWrapper that, required Uint8List piece, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_bpe_wrapper(that);
    var arg1 = _platform.api2wire_uint_8_list(piece);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner
          .wire_encode_single_token__method__BPEWrapper(port_, arg0, arg1),
      parseSuccessData: _wire2api_usize,
      constMeta: kEncodeSingleTokenMethodBpeWrapperConstMeta,
      argValues: [that, piece],
      hint: hint,
      parseErrorData: null,
    ));
  }

  FlutterRustBridgeTaskConstMeta
      get kEncodeSingleTokenMethodBpeWrapperConstMeta =>
          const FlutterRustBridgeTaskConstMeta(
            debugName: "encode_single_token__method__BPEWrapper",
            argNames: ["that", "piece"],
          );

  Future<Uint8List> decodeBytesMethodBpeWrapper(
      {required BPEWrapper that, required Uint32List tokens, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_bpe_wrapper(that);
    var arg1 = _platform.api2wire_uint_32_list(tokens);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner
          .wire_decode_bytes__method__BPEWrapper(port_, arg0, arg1),
      parseSuccessData: _wire2api_ZeroCopyBuffer_Uint8List,
      constMeta: kDecodeBytesMethodBpeWrapperConstMeta,
      argValues: [that, tokens],
      hint: hint,
      parseErrorData: null,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kDecodeBytesMethodBpeWrapperConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "decode_bytes__method__BPEWrapper",
        argNames: ["that", "tokens"],
      );

  Future<Uint8List> decodeSingleTokenBytesMethodBpeWrapper(
      {required BPEWrapper that, required int token, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_bpe_wrapper(that);
    var arg1 = api2wire_usize(token);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner
          .wire_decode_single_token_bytes__method__BPEWrapper(
              port_, arg0, arg1),
      parseSuccessData: _wire2api_ZeroCopyBuffer_Uint8List,
      constMeta: kDecodeSingleTokenBytesMethodBpeWrapperConstMeta,
      argValues: [that, token],
      hint: hint,
      parseErrorData: null,
    ));
  }

  FlutterRustBridgeTaskConstMeta
      get kDecodeSingleTokenBytesMethodBpeWrapperConstMeta =>
          const FlutterRustBridgeTaskConstMeta(
            debugName: "decode_single_token_bytes__method__BPEWrapper",
            argNames: ["that", "token"],
          );

  DropFnType get dropOpaqueCoreBpe => _platform.inner.drop_opaque_CoreBpe;
  ShareFnType get shareOpaqueCoreBpe => _platform.inner.share_opaque_CoreBpe;
  OpaqueTypeFinalizer get CoreBpeFinalizer => _platform.CoreBpeFinalizer;

  void dispose() {
    _platform.dispose();
  }
// Section: wire2api

  CoreBpe _wire2api_CoreBpe(dynamic raw) {
    return CoreBpe.fromRaw(raw[0], raw[1], this);
  }

  Uint32List _wire2api_ZeroCopyBuffer_Uint32List(dynamic raw) {
    return raw as Uint32List;
  }

  Uint8List _wire2api_ZeroCopyBuffer_Uint8List(dynamic raw) {
    return raw as Uint8List;
  }

  BPEWrapper _wire2api_bpe_wrapper(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return BPEWrapper(
      bridge: this,
      bpe: _wire2api_CoreBpe(arr[0]),
    );
  }

  int _wire2api_u32(dynamic raw) {
    return raw as int;
  }

  int _wire2api_u8(dynamic raw) {
    return raw as int;
  }

  Uint32List _wire2api_uint_32_list(dynamic raw) {
    return raw as Uint32List;
  }

  Uint8List _wire2api_uint_8_list(dynamic raw) {
    return raw as Uint8List;
  }

  int _wire2api_usize(dynamic raw) {
    return castInt(raw);
  }
}

// Section: api2wire

@protected
int api2wire_u32(int raw) {
  return raw;
}

@protected
int api2wire_u8(int raw) {
  return raw;
}

@protected
int api2wire_usize(int raw) {
  return raw;
}
// Section: finalizer
